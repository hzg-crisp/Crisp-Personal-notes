# Java知识点的总结：

### 1.黑窗口的使用；

- javac:编译。javac  文件名.class
- java：执行。java  类名
- 如果类名前加public，文件名和类名可以不一致。但加public后一定要保持类名和文件名的一致

**常见的das命令：**

- d ：回车，盘符切换
- dir(directory) ：列出当前目录下的文件以及文件夹
- md (make directory) ：创建目录   
- rd (remove directory) ： 删除目录
- cd (change directory) ：改变指定目录(进入指定目录)
- cd.. ：退回到上一级目录
- cd\ ： 退回到根目录
- del (delete) ：删除文件，删除一堆后缀名一样的文件 *.txt
- exit ：退出dos命令行
- cls (clear screen) ：清屏

### 2.如何认识虚拟机？jdk？为什么安装jdk

### 3.数据类型：（p17）

- 基本数据类型：四类八种，

  基本数据类型: 基本数据类型是Java语言中内置的类型，分别是整数类型、小数类型、字符类型、布尔类型。

  四类八种：

  整数(byte、short、int、long)、

  小数(float、double)、

  字符类型(char)、

  布尔类型(boolean)

- 引用数据类型：String，类，数组

  是强大的数据类型，它是基于基本数据类型创建的。JavaSE中提供了一个超级类库，类库中包含了近万种引用数据类型。（数组，类，接口）

### 4.关键字与标识符（p18）

什么是标识符？标识符可以由那些组成？（汉字可以是标识符吗？（**可以**）能不能以数字开头（**不可以**））标识符可不可以是关键字和保留字

英文大小写字母，数字，下划线，$

注意：数字不能开头，不能使用关键字，严格区分大小写，起名时见名知意

（1）包名：多单词组成时所有字母均小写，使用.连接  aaa.bbb.ccc

（2） 类名&接口名：大驼峰式   AaaBbbCcc

（3） 变量名&方法名：小驼峰式   aaaBbbCcc

（4）常量名：多单词组成是所有字母均大写，使用_连接AAA_BBB_CCC

### 5.常量，常量的定义（p22）

.变量：

一个有意思的东西：

\* A: 计算机中储存和运算的最小单位是? 	* a: 一个字节,也就是一个byte. 		* win+r--cmd--回车			 	* b: 常用储存单位 		*1B（字节） = 8bit 		*1KB = 1024B 		*1MB = 1024KB 		*1GB = 1024MB 		*1TB = 1024GB 		*1PB = 1024TB

四类八种的取值范围：

整型	byte	1	-128～127

short	2	-32768～32767

int	4	-2147483648～2147483648

long	8	-263～263-1

*浮点型	float	4	-3.403E38～3.403E38

double	8	-1.798E308～1.798E308

*字符型	char	2	表示一个字符，如('a'，'A'，'0'，'家')

*布尔型	boolean	1	只有两个值true与false

A:常量的定义

- a: 整形常量默认是int类型

- - b: 小数常量默认是double类型
  - c: 定义长整形数据如果值超过int取值范围后面要+"L"
  - d: 定义float类型的数据后面要+"f" 否则默认是double

### 6.数据类型转换（p23）

类型转换顺序：byte--short--char--int--long--float--double;

1. 自动类型转换
2. 强制类型转换

### 7.实操一下，使用Scanner输入一个数字，然后输出；

Scanner类的使用；

\* A: Scanner类的使用

​	* a: 导包import java.util.Scanner;

​	* b：创建键盘录入对象 Scanner sc = new Scanner(System.in);

​	* c: 读取键盘录入的一个整数

​		* int enterNumber = sc.nextInt();

​	* d: 读取键盘录入的字符串

​		* String enterString = sc.next();

### 8.算术运算符

1.++i   i++  --i  i--   %   /   a+=2的原始式子：a=a+2;

​				题：2.5+5/2+3.14+6%4

2. 三元运算符：

   格式: (条件表达式)？表达式1：表达式2；

   问题1：String result = (a==b) ? “相等” : “不相等”;  问题2：int n = (3>2 && 4>6) ? 100 : 200;

### 9.逻辑运算符

运算符	运算规则	范例		结果 

   &         与	        false&true   False 

​	|		或			false|true	True 

​	^		异或		true^flase	True 

​	!		非			!true	      	Flase

 &&	  短路与    false&&true	False

 ||	   短路或	false||true	True

### 10字符串的拼接

### for循环的执行流程 

​	for（① ; ② ; ③）{ 		④ 	} 	第一步，执行① 	第二步，执行②，如果判断结果为true，执行第三步，如果判断结果为false，执行第五步 	第三步，执行④ 	第四步，执行③，然后重复执行第二步 	第五步，退出循环

### 11三种注释

1. 单行注释
2. 多行注释
3. 文档注释

### 12.switch（43）

1. ·switch 后面括号内的“表达式”必须是整数类型。也就是说可以是 int 型变量、char 型变量，也可以直接是整数或字符常量，哪怕是负数都可以。但绝对不可以是实数，float 型变量、double 型变量、小数常量通通不行，全部都是语法错误。


### 13.while和do ...while的区别和联系（46）

### 14循环中的跳转语句

1. break：

   break详细解释 

   a: 作用 	

   1. 在loop/switch选择或者循环过程中，我们总是满足布尔表达条件才能执

   行对应的代码，然而在这些逻辑过程中，可以使用一些关键字直接跳出

   正在执行的代码，去执行后边或者指定位置的代码，这些关键字一旦出

   现就可以跳转语句执行顺序。 	

   2. 使用方式：
      - 无法单独使用，必须将break关键字置于switch或循环语句中运行规律 	
      -  不需要判断任何条件，只要遇到break变直接跳出执行后续代码。会完全

   3. 运行规律 	
      - 不需要判断任何条件，只要遇到break变直接跳出执行后续代码。会完全跳出选择或者循环结构 		
      -  只能跳出最近的代码块，不能跨越多级代码块

2. continue：

   作用：	

   * 提前结束本次循环，继续进行下次循环 * b: 使用方式 	* 无法单独使用，必须将continue关键字置于循环语句中 * c：运行规律 	* 不需要判断任何条件，只要遇到continue变直接跳出本轮循环进行下次循环

3. return：执行这行语句后，之后的代码还执行吗？不执行

### 15数组的几种定义方法：可以实操一下

**实操：**定义一个3*5的数组并自己遍历出来

​	数组的概述：数组是指一组数据的集合，数组中的每个数据被称作元素。在数组中可以存放任意类型的元素，但同一个数组里存放的元素类型必须一致。

**数组的定义：**

a:格式: 		数据类型[] 数组名 = new 数据类型[元素个数或数组长度];

b.举例：

int[] x = new int[100];

c.重点说明:

​	1)数据类型: 数组中存储元素的数据类型

​	2) [] 表示数组的意思

​	3) 变量名  自定义标识符  

​	4) new  创建容器关键字

​	5)数据类型: 数组中存储元素的数据类型

​	6)元素个数,就是数组中,可以存储多少个数据 (恒定, 定长)

**为数组的元素赋值:**

​		int[] arr = new int[4]; // 定义可以存储4个整数的数组

​		arr[0] = 1; // 为第1个元素赋值1 	 				 

​	    arr[1] = 2; // 为第2个元素赋值2

​		.....

​		类型[] 数组名 = new 类型[]{元素，元素，……};

​			int[] arr = new int[]{1,2,3,4};

​			类型[] 数组名 = {元素，元素，元素，……};	  					     int[] arr = { 1, 2, 3, 4 };

 **二维数组：**

​	定义二维数组：

​	1.int[][] arr = new int[3][4];然后在一个个赋值

​	2.int [][] arr = {{1,2,4},{4,7},{0,9,3}};

​	遍历二维数组：

​	public class Test_003 {

​	public static void main(String[] args) {

​		int [][]arr = {{1,2,3},{6,5,3},{8,6,7}};

​		for(int i=0;i<arr.length;i++) {

​			for(int j=0;j<arr[i].length;j++) {

​				System.out.print(arr[i][j]);

​			}

​			System.out.println();

​		}

​	}

}

foreach的使用（p63）

### 16如何理解类与对象，什么是面向对象

  A: 类和对象的关系 	

​		* 类是对某一类事物的抽象描述，而对象用于表示现实中该类事物的个体 	*

B: 举例 	

​		* 可以将玩具模型看作是一个类，将一个个玩具看作对象，从玩具模型和玩具		

之间的关系便可以

### 17.方法：（重点）；

**A.方法的格式：**

修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) { 	

​	方法体语句; 	

​	return 返回值;  

​	} 

**B.方法的格式说明:**

   \* 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。 

 * 返回值类型：就是功能结果的数据类型。
 * 实际参数：就是实际参与运算的。 		
 *  形式参数；就是方法定义上的，用于接收实际参数的。 	
 * 参数类型：就是参数的数据类型 	
 * 参数名：就是变量名 	
 *  方法体语句：就是完成功能的代码。 	
 *  return：结束方法的。 	
 * 返回值：就是功能的结果，由return带给调用者。 
 * 方法名：符合命名规则即可。方便我们的调用。 
* 实际参数：就是实际参与运算的。 

**C.方法的定义和使用的注意事项:** 	

* a: 方法不能定义在另一个方法的里面 
*  b: 写错方法名字。 	
*  c: 写错了参数列表 	*
* d: 方法返回值是void,方法中可以省略return 不写 	     return 下面不能有代码 	
* e 方法返回值类型,和return 后面数据类型必须匹配 	
*  f: 方法重复定义问题 	
*  g: 调用方法的时候,返回值是void, 不能写在输出语句中

**D.方法的重载：**

在同一个类中，方法名相同，参数列表不同。与返回值类型无关。

（参数列表不同：

* A:参数个数不同

* B:参数类型不同

* C:参数的顺序不同(算重载,但是在开发中不用)）

**注意事项：**   

​	a: 参数列表必须不同 

​	b: 重载和参数变量名无关 

​	c: 重载和返回值类型无关 

​	d: 重载和修饰符无关 

​	e: 技巧: 重载看方法名和参数列表

**E.方法参数：**

* a: 方法参数是基本类型时，传递的是值。

* b: 方法参数是引用类型时，传递的是内存地址值。

### 18自定义类：

A.自定义的格式：

\* a: 使用类的形式,对现实中的事物进行描述。 	

* b: 事物由方法和属性两部分组成。 		
* 方法: 这个事物具备的功能。 	

* 属性: 这个事物具备的特征。	

* c: 格式 		public class 类名{ 			
* 属性定义 			  
* 修饰符 数据类型 变量名 = 值

​	方法定义

​				     修饰符 返回值类型  方法名(参数列表){

​				  }

​			}

举例：

public class DianFanGuo{

​		//定义三个属性

​		String brand ;

​	        double size ;

​		String color ;

​	}

public class Test{

​		public static void main(String[] args){

​			//创建电饭锅引用类型

​			DianFanGuo dfg = new DianFanGuo();

​			

​			dfg.brand = "特斯拉";

​			dfg.color = "红色";

​			dfg.size = 30;

​			

​			System.out.println(dfg.brand+"  "+dfg.color+"  "+dfg.size);

​			

​			//创建汽车引用类型

​			Car c = new Car();

​			c.brand = "巨力";

​			c.type = "拖拉机";

​			c.paiLiang = 0.5;			

​			System.out.println(c.brand+"  "+c.type+"  "+c.paiLiang);



### 19成员变量与局部变量的区别

- 区别一：定义的位置不同

- - 定义在类中的变量是成员变量
  - 定义在方法中或者{}语句里面的变量是局部变量

- 区别二：在内存中的位置不同

- - 成员变量存储在对内存的对象中
  - 局部变量存储在栈内存的方法中

- 区别三：声明周期不同

- - 成员变量随着对象的出现而出现在堆中，随着对象的消失而从堆中消失
  - 局部变量随着方法的运行而出现在栈中，随着方法的弹栈而消失

- 区别四：初始化不同

- - 成员变量因为在堆内存中，所以有默认的初始化值
  - 局部变量没有默认的初始化值，必须手动的给其赋值才可以使用。



### 20.重载

参考17方法；



### 21.构造方法

#### **A.理解：**

​	从字面上理解即为构建创造时用的方法，即就是对象创建时要执行的方法。既然是		

​	对象创建时要执行的方法，那么只要在new对象时，知道其执行的构造方法是什么，

​	就可以在执行这个方法的时候给对象进行属性赋值。

#### **B.构造方法的作用：**

​	在new的同时给成员变量赋值,给对象属性进行初始化；

​	Person p = new Person("张三",23); 在new 的时候给p对象的name属性和age属

​	性进行赋值,使这个对象的属性有值。

#### **C.构造方法的定义和运行条件：**

​	1.构造方法的格式： 		

​		修饰符 构造方法名(参数列表) 		{ 		}

2. 构造方法的体现： 

   1.构造方法没有返回值类型。也不需要写返回值。因为它是为构建对象的，对象创建完，方法就执行结束.

   2.构造方法名称必须和类型保持一致。

​	    3.构造方法没有具体的返回值。

​		4.构造方法的代码体现：

3.构造方法举例：

class Person {

​			// Person的成员属性age和name

​			private int age;

​			private String name;

​		

​			// Person的构造方法，拥有参数列表

​			Person(int a, String nm) {

​				// 接受到创建对象时传递进来的值，将值赋给成员属性

​				age = a;

​				name = nm;

​			}

​		}

4.构造方法的运行特点：

 	在new 对象的时候自动调用执行；

#### **D.构造方法的重载：**

​	1.当在描述事物时，要不要在类中写构造方法呢？这时要根据描述事物的特点来

确定，当描述的事物在创建其对象时就要明确属性的值，这时就需要在定义类的

时候书写带参数的构造方法。

2. 若创建对象时不需要明确具体的数据，这时可以不用书写构造方法（不书写

也有默认的构造方法）。

**构造方法的细节：**

1）一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的

 2）构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。

#### **E：构造方法和一般方法的区别：**

目前为止，学习两种方法，分别为构造方法和一般方法，那么他们之间有什么异同呢？

**1.格式不同** 	 构造方法 : 修饰符  类名(参数类型 参数 ...){ 		初始化成员变量 	} 	一般方法: 需要有返回值类型 

**2.作用不同** 	构造方法一般用来给成员变量初始化; 	一般方法根据需求而定; 	

**3.调用方式不同** 	构造方法创建对象时调用, 或者this() super() 语句调用 	普通方法需要对象调用或者静态方法直接调用静态方法. 	

**4.执行不同** 	构造方法在对象创建时就执行了，而且只执行一次。 	一般方法是在对象创建后，需要使用时才被对象调用，并可以被多次调用。

#### **F.this在构造方法之间调用；**

构造方法之间的调用，可以通过this关键字来完成。      构造方法调用格式：      this(参数列表);



### 22.static

#### A.概念：

​	当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。当在调用对	象的某个方法时，这个方法没有访问到对象的特有数据时，方法创建这个对象有些多余。可是不创建对象，方	法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢可以的，我们可以通过static关键	字来实现。static它是静态修饰符，一般用来修饰类中的成员。

#### B:static修饰的对象特有数据	

​	a.被static修饰的成员变量属于类，不属于这个类的某个对象。（也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量）

class Demo { 	            public static int num = 100;                }

class Test {

​			public static void main(String[] args) {

​				Demo d1 = new Demo();

​				Demo d2 = new Demo();

​				d1.num = 200;

​				System.out.println(d1.num); //结果为200

​				System.out.println(d2.num); //结果为200

​			}

​		}

#### C.static注意事项_静态不能直接调用非静态

a.被static修饰的成员可以并且建议通过类名直接访问。

b.访问静态成员的格式：

​		类名.静态成员变量名

​		类名.静态成员方法名(参数)

​		对象名.静态成员变量名     	------不建议使用该方式，会出现警告

​		对象名.静态成员方法名(参数)       ------不建议使用该方式，会出现警告

c.举例：

class Demo {

​			//静态成员变量

​			public static int num = 100;

​			//静态方法

​			public static void method(){

​				System.out.println("静态方法");

​			}

​		}

​		class Test {

​			public static void main(String[] args) {

​				System.out.println(Demo.num);

​				Demo.method();

​			}

​		}

#### D.static的使用场景：

a.使用场景：static可以修饰成员变量和成员方法。	

1.什么时候使用static修饰成员变量？

加static修饰成员的时候，这个成员会被类的所有对象所共享。一般我们把共性数据定义为静态的变量

2.什么时候使用static修饰成员方法？

静态的方法只能访问静态的成员，如果静态方法中引用到了静态的其他成员，那么这个方法需要声明为静态的方法。

#### E.定义静态常量：

\* a: 静态常量 	开发中，我们想在类中定义一个静态常量，通常使用public static final修饰的变量来完成定义。此时变量名用全部大写，多个单词使用下划线连接。 * b: 定义格式： 	public static final 数据类型 变量名 = 值;

注意：接口中的每一个变量都默认使用public static final修饰；所有接口中的成员变量已是静态常量，由于接口没有构造方法，所以必须显示赋值。可以直接用接口名访问。

interface Inter {

​		public static final int COUNT = 100;

​	}

Inter.COUNT；

### 23.继承

#### A:继承的概念:     

​	*a:继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系      	 

 	*b:在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类      

#### B:继承关系的子类特点  :           

​	 *a:子类会自动拥有父类所有非private修饰的属性和方法

#### C：继承的格式：

​	class 子类 extends 父类 {}；

#### D：继承的好处：  

​      *1、继承的出现提高了代码的复用性，提高软件开发效率。   

​     *2、继承的出现让类与类之间产生了关系，提供了多态的前提。

#### E：继承的注意事项：

​	 *a:在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直

​     接父类。

​	 *b:多个类可以继承一个父类；

​	 *c:在Java中，多层继承是可以的， 即一个类的父类可以再去继承另外的父类；

​	 *d:在Java中，子类和父类是一种相对概念，  也就是说一个类是某个类父类的同	

​      时，也可以是另一个类的子类。

#### F：继承后子类父类成员变量的特点 ：

​	  a:子类的对象调用成员变量的时候,子类自己有,使用子类,子类自己没有调用的父

类。

​	  b:在子类中需要访问父类中非私有成员变量时，需要使用super关键字.

#### G:继承后子类父类成员方法的特性_子类重写父类方法:

​	 a:子类的对象调用方法的时候,子类自己有,使用子类,子类自己没有调用的父类

### 24.super关键字

#### A: 子父类中构造方法的调用

​		在创建子类对象时，父类的构造方法会先执行，因为子类中所有构造方法的第一行有默

认的隐式super();语句。

#### B: 格式：

​	调用本类中的构造方法

​	this(实参列表);

​	调用父类中的空参数构造方法

super();

​	调用父类中的有参数构造方法

​	super(实参列表);

#### C.通过结果发现，子类构造方法执行时中，调用了父类构造方法，这说明，子类构造方法中

​	有一句super()。

​	那么，子类中的构造方法为什么会有一句隐式的super()呢？

​	原因：子类会继承父类中的内容，所以子类在初始化时，必须先到父类中去执行父类的

初始化动作。这样，才可以使用父类中的内容。

​	当父类中没有空参数构造方法时，子类的构造方法必须有显示的super语句，指定要访

问的父类有参数构造方法。

#### D.构造方法第一行,写this()还是super()？

	*  this() 是调用本类的构造方法,super()是调用父类的构造方法, 且两条语句不能同时存在（他两都要放在方法里的第一行） 	     
	*  保证子类的所有构造方法调用到父类的构造方法即可

#### E.创建子类对象过程的细节：

A创建子类对象过程的细节           

* 如果子类的构造方法第一行写了this调用了本类其他构造方法，那么super调用父类的语句还有吗？      
* 这时是没有的，因为this()或者super(),只能定义在构造方法的第一行，因为初始化动作要先执行。 	 

* 父类构造方法中是否有隐式的super呢？          
* 也是有的。记住：只要是构造方法默认第一行都是super();    
* 父类的父类是谁呢？super调用的到底是谁的构造方法呢？         
*  Java体系在设计，定义了一个所有对象的父类Object

####  注意：

​	类中的构造方法默认第一行都有隐式的super()语句，在访问父类中的空参数构造方法。

所以父类的构造方法既可以给自己的对象初始化，也可以给自己的子类对象初始化。

​	如果默认的隐式super()语句在父类中没有对应的构造方法，那么必须在构造方法中通过

this或者super的形式明确要调用的构造方法。

### 25.this的简单运用

A.当在方法中出现了局部变量和成员变量同名的时候，那么在方法中怎么区别局部变

量成员变量呢？可以在成员变量名前面加上this.来区别成员变量和局部变量。

B.举例：

class Person { 	private int age; 	private String name;

​	// 给姓名和年龄初始化的构造方法

​		Person(String name, int age) {

​			// 当需要访问成员变量是，只需要在成员变量前面加上this.即可

​			this.name = name;

​			this.age = age;

​		}

​		public void speak() {

5			System.out.println("name=" + this.name + ",age=" + this.age);

​		}

​	}

​	class PersonDemo {

​		public static void main(String[] args) {

​			Person p = new Person("张三", 23);

​			p.speak();

​		}

​	}



### 26.重写

定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称

为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。

要求：

​	1.子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表

​	2.子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型

​	3.子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限

​	 子类不能重写父类中声明为private权限的方法

​	4.子类方法抛出的异常不能大于父类被重写方法的异常

注意：

​	子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为

​	static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法。

### 27多态：

多态是同一个行为具有多个不同表现形式或形态的能力。

多态就是同一个接口，使用不同的实例而执行不同操作，（同一个事件发生在不同的对象上会产生不同的结果。）

*优点：*

1. 消除类型之间的耦合关系

2. 可替换性

3. 可扩充性

4. 接口性

5. 灵活性

6. 简化性

向上向下转型：

### 27.封装的概述：（重要）

\* A.面向对象三大特征 

 * 封装、继承、多态   

   **B.封装表现** 	

   1、方法就是一个最基本封装体 	

   2、类其实也是一个封装体	      

   **C.封装的好处（优点）** 	

    1、提高了代码的复用性 	

    2、隐藏了实现细节，还要对外提供可以访问的方式。便于调用者的使用。这

   ​     是核心之一，也可以理解为就是封装的概念 	

    3、提高了安全性	 

生活中的小例子：

机箱： 	一台电脑，它是由CPU、主板、显卡、内存、硬盘、电源等部件组长，其实我

​    们将这些部件组装在一起就可以使用电脑了，但是发现这些部件都散落在面，   

​    很容造成不安全因素，于是，使用机箱壳子，把这些部件都装在里面，并在机

​    箱壳上留下一些插口等，若不留插口，大家想想会是什么情况。

​		总结：机箱其实就是隐藏了办卡设备的细节，对外提供了插口以及开关等访问

 内部细节的方式。

### 28.抽象类的产生：

A:分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。

​    B：抽象类的定义格式

​		1.抽象方法的定义格式：

​				public abstract 返回值类型 方法名(参数);

​		2.抽象类的定义格式：

​				 abstract class 类名 {	

​					  }

  C：抽象类的使用：

### 29接口

#### A.类与接口的关系：

类与接口的关系为实现关系，即类实现接口。实现的动作类似继承，只是关

​      键字不同，实现使用implements。

#### B.类实现接口的方式：

class 类 implements 接口 { 		重写接口中方法 		} 

#### C.注意事项：

1.在类实现接口后，该类就会将接口中的抽象方法继承过来，此时该类需要重写 					  

   该抽象方法，完成具体的逻辑。

2.接口中定义功能，当需要具有该功能时，可以让类实现该接口，只声明了应该

   具备该方法，是功能的声明。

3.在具体实现类中重写方法，实现功能，是方法的具体实现。

#### D.接口中成员方法的特点：

\* a 接口中可以定义方法，方法也有固定的修饰符，public abstract      * b 子类必须覆盖掉接口中所有的抽象方法后，子类才可以实例化。否则子类是

一个抽象类。

  案例：

​		interface Demo { ///定义一个名称为Demo的接口。

​			public abstract void show1();

​			public abstract void show2();

​		}

​		

​		//定义子类去覆盖接口中的方法。类与接口之间的关系是 实现。通过 关键字 

implements

​		class DemoImpl implements Demo { //子类实现Demo接口。

​			//重写接口中的方法。

​			public void show1(){}

​			public void show2(){}

​		}

#### E.接口的实现类：

​     一个类如果实现类接口,有两种操作方法:    第一:实现类是非抽象类,就需要重写接口中所有的抽象方法.    第二:实现类也声明为抽象类,那么实现类可以不重写接口中的抽象方法。

F.接口的多实现 了解了接口的特点后，那么想想为什么要定义接口，使用抽象类描述也没有问题，

  接口到底有啥用呢？ 接口最重要的体现：解决多继承的弊端。将多继承这种机制在java中通过多实现完

  成了。

* A: 接口的多继承 	* 学习类的时候，知道类与类之间可以通过继承产生关系，接口和类之间可以

​            通过实现产生关系，那么接口与接口之间会有什么关系。 	* 多个接口之间可以使用extends进行继承。

#### H.接口和抽象类区别总结：

相同点:

​		都位于继承的顶端,用于被其他类实现或继承;

​		都不能直接实例化对象;

​		都包含抽象方法,其子类都必须覆写这些抽象方法;

​	区别:

​		抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;接口

​                只能包含抽象方法;

​		一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补

 了Java的单继承)

​		抽象类是这个事物中应该具备的你内容, 继承体系是一种 is..a关系

​		接口是这个事物中的额外内容,继承体系是一种 like..a关系

​	

​	二者的选用:

​		优先选用接口,尽量少用抽象类;

​		需要定义子类的行为,又要为子类提供共性功能时才选用抽象类;

### 30.Final的使用



### 31.匿名对象：

A.匿名对象的概述：

 匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。

B.案例：

​	public class Person{ 			public void eat(){ 				System.out.println(); 			} 	}

​	创建一个普通对象

​	Person p = new Person();

​	创建一个匿名对象

​	new Person();

C.匿名对象的特点：

1）：创建匿名对象直接使用，没有变量名。

​	new Person().eat()  //eat方法被一个没有名字的Person对象调用了。

2）：匿名对象在没有指定其引用变量时，只能使用一次。

new Person().eat(); 创建一个匿名对象，调用eat方法

new Person().eat(); 想再次调用eat方法，重新创建了一个匿名对象

3）：匿名对象可以作为方法接收的参数、方法返回值使用：

​	class Demo {

​			public static Person getPerson(){

​				//普通方式

​				//Person p = new Person();	

​				//return p;

​				

​				//匿名对象作为方法返回值

​				return new Person(); 

​			}

​			

​			public static void method(Person p){}

​		}

​		class Test {

​			public static void main(String[] args) {

​				//调用getPerson方法，得到一个Person对象

​				Person person = Demo.getPerson();

​				

​				//调用method方法

​				Demo.method(person);

​				//匿名对象作为方法接收的参数

​				Demo.method(new Person());

​			}

​		}

### 32.内部类

#### A.内部类的概述：

将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。其他类也称为外部类。

#### B.什么时候使用内部类：

在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机，这时发动机就可以使用内部类来描述。 	class 汽车 { //外部类 		class 发动机 { //内部类 		} 	}

#### C.内部类的分类：

内部类分为成员内部类与局部内部类。我们定义内部类时，就是一个正常定义类的过程，同样包含各种修饰符、继承与实现关系等。在内部类中可以直接访问外部类的所有成员。

1）：成员内部类的调用格式

a.格式：成员内部类，定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问

b.定义格式：

class 外部类 {  	修饰符 class 内部类 { 		//其他代码 		} 	}

c.访问方式：外部类名.内部类名 变量名 = new 外部类名().new 内部类名();

d.代码演示：

成员内部类代码演示

​	class Body {//外部类，身体

​		 private boolean life= true; //生命状态

​		 public class Heart { //内部类，心脏

​			 public void jump() {

​				System.out.println("心脏噗通噗通的跳")

​				System.out.println("生命状态" + life); //访问外部类成员变量

​			}

​		}

​	}

​	访问内部类

​	public static void main(String[] args) {

​		//创建内部类对象

​		Body.Heart bh = new Body().new Heart();

​		//调用内部类中的方法

​		bh.jump();

​	}

**2）：局部内部类：**

a： 局部内部类，定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过调用方法进行访问.

b： 定义格式

class 外部类 {  		修饰符 返回值类型 方法名(参数) { 		class 内部类 { 			//其他代码 				} 			} 		}

c.访问方式：在外部类方法中，创建内部类对象，进行访问

d.案例代码：

class Party {//外部类，聚会

​		public void puffBall(){// 吹气球方法

​			class Ball {// 内部类，气球

​				  public void puff(){

​					System.out.println("气球膨胀了");

​				  }

​			}

​			//创建内部类对象，调用puff方法

​			new Ball().puff();

​		}

​	}

​	访问内部类

​	public static void main(String[] args) {	

​		//创建外部类对象

​		Party p = new Party();

​		//调用外部类中的puffBall方法

​		p.puffBall();

​	}

现在外部类中调用内部类的方法访问内部类。然后可以调用外部类来调用外部类中内部类的内容；

#### **匿名内部类：**

A.概述：

内部类是为了应对更为复杂的类间关系。查看源代码中会涉及到，而在日常业务中很难遇到，这里不做赘述。最常用到的内部类就是匿名内部类，它是局部内部类的一种。

B.本质：

匿名内部类的本质是一个实现了接口或继承了某个类的子类匿名对象.

### 33.枚举

一枚一枚可以例举出来的，才建议使用枚举类型；

枚举编译之后也是生成class文件，

枚举也是一种引用数据类型，

枚举中的每一个值都可以看做是一个常量。

例如：

enum Result{

SUCESS,FALL

}

SUCCESS,FALL都是枚举Result类型中的一个值。枚举中的每一个值都可以看作是“常量”

总结：

1.枚举是一种引用数据类型

2.枚举类型怎么定义，语法是？

enum 枚举类型名{

枚举值1，枚举值2...

}

3.结果只有两种情况的，建议使用布尔类型，结果超过两种的并且可以一个一个列举出来的，建议使用枚举类型。例如：颜色，四季，

4.switch也支持枚举类型，switch也支持String，int，高版本jgk还支持，byte，short，char，因为存在自动类型转换。

### 34.包(了解)

 \* A: 概念 	java的包，其实就是我们电脑系统中的文件夹，包里存放的是类文件。当类文件很多的时候，通常我们会采用多个包进行存放管理他们，这种方式称为分包管理。在项目中，我们将相同功能的类放到一个包中，方便管理。并且日常项目的分工也是以包作为边界。类中声明的包必须与实际class文件所在的文件夹情况相一致，即类声明在a包下，则生成的.class文件必须在a文件夹下，否则，程序运行时会找不到类。

27权限修饰符：

 在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限， 	以下表来说明不同权限的访问能力： 					            public	      protected	     default	  private        同一类中	              		       √	            √	                  √	              √        同一包中(子类与无关类)	       √	            √	                  √	        不同包的子类	                       √	            √		        不同包中的无关类	               √			

小结：

归纳一下：在日常开发过程中，编写的类、方法、成员变量的访问 	要想仅能在本类中访问使用private修饰； 	要想本包中的类都可以访问不加修饰符即可； 	要想本包中的类与其他包中的子类可以访问使用protected修饰 	要想所有包中的所有类都可以访问使用public修饰。 	注意：如果类用public修饰，则类名必须与文件名相同。一个文件中只能有

​    一个public修饰的类。

### 35.不同修饰符的使用细节

#### A:常用来修饰类，方法，变量的修饰符细节；

	public 权限修饰符，公共访问, 类,方法,成员变量

	protected 权限修饰符，受保护访问, 方法,成员变量

	默认什么也不写 也是一种权限修饰符，默认访问, 类,方法,成员变量

	private 权限修饰符，私有访问, 方法,成员变量

	static 静态修饰符  方法,成员变量

	final 最终修饰符   类,方法,成员变量,局部变量

	abstract 抽象修饰符  类 ,方法

#### B: 不能同时使用的修饰符

​	同时，abstract与private不能同时使用；

​	同时，abstract与static不能同时使用；

​	同时，abstract与final不能同时使用。

#### C: 修饰类能够使用的修饰符： 	修饰类只能使用public、默认的、final、abstract关键字 	使用最多的是 public关键字

a:代码案例

​		public class Demo {} //最常用的方式

​		class Demo2{}

​		public final class Demo3{}

​		public abstract class Demo4{}

#### D:修饰成员变量能够使用的修饰符：

​	public : 公共的

​	protected : 受保护的: 默认的

​	private ：私有的

​	final : 最终的

​	static : 静态的

​	使用最多的是 private

a: 代码案例：

​		public int count = 100;

​		protected int count2 = 100;

​		int count3 = 100;

​		private int count4 = 100; //最常用的方式

​		public final int count5 = 100;

​		public static int count6 = 100;

#### E:修饰构造方法能够使用的修饰符： 	public : 公共的 	protected : 受保护的: 默认的 	private ：私有的 	使用最多的是 public

a:代码案例：

​		public Demo(){} //最常用的方式

​		protected Demo(){}

​		Demo(){}

​		private Demo(){}

#### F：修饰成员方法能够使用的修饰符：

public : 公共的

protected : 受保护的: 默认的

private ：私有的

final : 最终的

static : 静态的

abstract : 抽象的

使用最多的是 public

public void method1(){}//最常用的方式：

​	protected void method2(){}

​	void method3(){}

​	private void method4(){}

​	public final void method5(){}

​	public static void method6(){}//最常用的方式

​	public abstract void method7();//最常用的方式

### 36.ArrayList的简单使用

   12.1* A: ArrayList创建变量的步骤 	* a: 导入包 java.util包中 	* b: 创建引用类型的变量 		数据类型< 集合存储的数据类型>  变量名 = new 数据类型<集合存储的数	

据类型>（）；    		集合存储的数据类型: 要将数据存储到集合的容器中    		创建集合引用变量的时候,必须要指定好,存储的类型是什么 	* c: 变量名.方法      	注意: 集合存储的数据,8个基本类型对应8个引用类型  		存储引用类型,不存储基本类型

12.2：ArrayList创建变量举例：

import java.util.ArrayList; 			public class ArrayListDemo{ 			public static void main(String[] args){ 			//创建集合容器,指定存储的数据类型 			//存储字符串 			ArrayList<String> array = new ArrayList<String>();

​	//创建集合容器,存储整数

​			ArrayList<Integer> array2 = new ArrayList<Integer>();	

​			//创建集合容器,存储手机类型

​			ArrayList<Phone> array3 = new ArrayList<Phone>();

​		}

​	}

12.3ArrayList的常见方法：

​     \* A: ArrayList的常见方法： 			* a: add(参数) 向集合中添加元素 			* b: get(int index) 取出集合中的元素,get方法的参数,写入索引 			* c: size() 返回集合的长度, 集合存储元素的个数

案例代码：

import java.util.ArrayList;

public class Test_006 {

​	public static void main(String[] args) {

​		ArrayList<String>array = new ArrayList<String>();

​        //调用集合方法 add（）储存元素

//此处使用的是String 所以add里面的添加元素主要家引号；

​		array.add("abc");

​		array.add("123");

​		array.add("java");

​		//输出集合的长度，调用集合的方法size，size方法的返回值类型int；

​		int size = array.size();

​		System.out.println(size);

​		//利用get()方法获得1索引的元素；

​		String s = array.get(1);

​		System.out.println(s);

​	}

}

12.4ArrayList集合的遍历：

/* 		   集合的遍历 		   实现思想也是索引思想 		   集合的索引从0开始,到 size()-1 	 	 方法get(int index) 		*/

实操代码：

package luke;

import java.util.ArrayList;

public class Test_007 {

​	public static void main(String[] args) {

​		ArrayList<Integer>array=new ArrayList<Integer>();

​		array.add(123);

​		array.add(654);

​		array.add(987);

​		array.add(852);

​		array.add(963);

​		for(int i=0;i<array.size();i++) {

​			System.out.println(array.get(i));

​		}

​	}

}

12.5ArrayList补充方法：

- a: add(int 索引,存储的元素) 	     
- 将元素添加到指定的索引上 		
- b: set(int 索引,修改后的元素) 	将指定索引的元素,进行修改 		
- c: remove(int 索引) 			删除指定索引上的元素 		
- d: clear() 					清空集合中的所有元素

### 37。接口与适配器的区别：

适配器：只是一个类，此类中实现了接口中的定义方法，并对方法进行重写，以达到特定的目的。

接口（interface）：实际上就是定义了某些规范的java方法，只提供方法的定义，而不具体的进行实现，也就是类中都是抽象方法；

- 接口不能用于实例化对象。
- 接口没有构造方法。
- 接口中所有的方法必须是抽象方法。
- 接口不能包含成员变量，除了 static 和 final 变量。
- 接口不是被类继承了，而是要被类实现。
- 接口支持多继承。

区别：适配器只需重写需要的事件处理方法，而接口需要实现全部的方法。

### 38Java随机数

- 通过System.currentTimeMillis()来获取随机数。实际上是获取当前时间毫秒数，它是long类型。使用方法如下：

final long l = System.currentTimeMillis();

若要获取int类型的整数，只需要将上面的结果转行成int类型即可。比如，获取[0, 100)之间的int整数。方法如下：

final long l = System.currentTimeMillis();    final int i = (int)( l % 100 );

- 通过Math.random()来获取随机数。实际上，它返回的是0(包含)到1(不包含)之间的double值。使用方法如下：

final double d = Math.random();

若要获取int类型的整数，只需要将上面的结果转行成int类型即可。比如，获取[0, 100)之间的int整数。方法如下：

final double d = Math.random(); final int i = (int)(d*100);

### 39.==和equal的联系与区别：

1. 最大的区别是，==是运算符，equal是方法

2. 简述几种情况下的equal和==
   - java基本类型（short，int，long，byte，char，float，double，boolean）
     - 比较基本类型，只能用==，不能用equal，这里的==比较的是两个变量的值
   - 比较包装类型
     - ==比较的是内存地址，因为a和b是new出来的，是两个不同的对象，所以地址肯定是不同的，而equal比较的是值，

![img](https://img2018.cnblogs.com/blog/1358633/201905/1358633-20190531111739338-1091271760.png)

- .比较String类型
  - ==比较的是内存地址，equal比较的是值
- 比较对象
  - ==和equal比较的都是内存地址，因为equal没有被重写，没有被重写的equal都是object的equal方法

### 38.异常

### 39.线程的五种状态





















